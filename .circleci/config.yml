version: 2.1

# Define executors that various packaging jobs need.  This lets us make one
# packaging job that accepts an executor parameter and avoids duplicating the
# packaging steps.
executors:
  manylinux-2014-x86_64:
    docker:
      - image: "quay.io/pypa/manylinux2014_x86_64"
  manylinux_2_24-x86_64:
    docker:
      - image: "quay.io/pypa/manylinux_2_24_x86_64"

  # Since this executor doesn't use a pypa-defined image created specifically
  # for building wheels, we're a little bit less confident of exactly what
  # kind of manylinux wheel will come out of it.  x_y here is a reference to
  # the "future-proof" (heh) PEP 600 manylinux definition.  For a given pinned
  # image, we should probably always get the same version out (eg
  # manylinux_2_17 as of ubuntu-2004:202101-01) but if glibc on the system is
  # upgraded then we'll probably get higher numbers.
  manylinux_x_y-aarch64:
    machine:
      image: "ubuntu-2004:202101-01"
    resource_class: "arm.large"

# Define some custom commands that we can use as elements of `steps` in job
# definitions.
commands:
  build-wheel:
    description: "Build a Python wheel"

    parameters:
      python:
        description: "The path to the Python executable to use"
        type: "string"
        default: "python3"

    steps:
      - "checkout"
      - run:
          # And the rest of it.
          name: "Finish checking out source"
          command: |
            git submodule init
            git submodule update
            git fetch --tags

      - run:
          name: "Install Rust Build Toolchain"
          command: |
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > /tmp/rustup-init
            for i in $(seq 10); do
                if sh /tmp/rustup-init -y --default-toolchain stable; then
                    break
                else
                    sleep 1
                fi
            done
            echo '. "$HOME"/.cargo/env' >> $BASH_ENV

      - run:
          name: "Get Python Build/Package Dependencies"
          command: |
            # Make sure we have a pip that's aware of Python version constraints
            << parameters.python >> -m pip install --upgrade pip
            # Pre-install these two setup_depends using pip so we don't have
            # to rely on whatever resolution logic setuptools would apply.
            << parameters.python >> -m pip install --upgrade milksnake setuptools_scm
            # And get these so we can build, fix, and upload a wheel.
            << parameters.python >> -m pip install wheel auditwheel twine

      - run:
          name: "Build Wheel"
          command: |
            << parameters.python >> -m pip wheel --no-deps .

      - run:
          name: "Audix / Fix Wheel "
          command: |
            # Since both macOS and Linux jobs re-use this step, make sure we
            # only try to use auditwheel on the appropriate platform.  That
            # is, only on Linux.
            case "${CIRCLE_JOB}" in
              *manylinux*)
                << parameters.python >> -m auditwheel repair python_challenge_bypass_ristretto*.whl
                # Delete the original, unfixed wheel.
                rm *.whl
                # Move the fixed wheel here for consistency with the
                # non-manylinux case.
                mv wheelhouse/python_challenge_bypass_ristretto*.whl ./
                ;;
            esac

      - run:
          name: "Upload Wheel"
          environment:
            # PyPI authentication configuration for twine so we can upload
            # packages.  TWINE_PASSWORD is set in the CircleCI private
            # configuration section.  In the CircleCI web app:
            #
            #    Project Settings ->
            #    Environment Variables ->
            #    Add Environment Variable ->
            #    Name: TWINE_PASSWORD
            #    Value: <a token issued by PyPI>
            #
            # The PyPI token is issued in the PyPI web app:
            #
            #    Manage ->
            #    Settings ->
            #    Create a token for ... ->
            #    Permissions: Upload
            #    Scope: Project: python-challenge-bypass-ristretto
            TWINE_USERNAME: "__token__"

          command: |
            if [[ "$CIRCLE_TAG" == v* ]]; then
              # We're building a release tag so we should probably really
              # release it!
              repo="pypi"
            else
              # We're building anything else.  Exercise as much of the release
              # code as possible - but send it to the "test" package index,
              # not the "real" one.
              repo="testpypi"
              TWINE_PASSWORD="$TWINE_TESTPYPI_PASSWORD"
            fi
            << parameters.python >> -m twine upload --repository $repo python_challenge_bypass_ristretto*.whl

# Define the actual jobs that will be available to run in a workflow.
jobs:

  # Build a manylinux wheel.
  package-manylinux:
    parameters:
      executor:
        # note the name comes from the `executors` section above
        description: "the name of the executor to use to run this job"
        type: "executor"

      pre-command:
        description: |
          a command to run first which resolves any inconsistencies between
          the chosen executor and the requirements of this job
        type: "string"
        default: ""

      python:
        description: "the path to the Python executable to use"
        type: "string"


    executor: "<< parameters.executor >>"

    steps:
      - run:
          name: "Prepare Execution Environment"
          command: |
            << parameters.pre-command >>

      - "build-wheel":
          python: "<< parameters.python >>"

  package-macos:
    parameters:
      xcode-version:
        type: "string"

    macos:
      xcode: "<< parameters.xcode-version >>"

    steps:
      - "build-wheel"

  tests-template: &TESTS
    docker:
      # Run in a highly Nix-capable environment.
      - image: "nixorg/nix:circleci"

    environment:
      # Specify a revision of NixOS/nixpkgs to run against.  This essentially
      # pins the majority of the software involved in the build.  This
      # revision is selected arbitrarily.  It's somewhat current as of the
      # time of this comment.  We can bump it to a newer version when that
      # makes sense.  Meanwhile, the platform won't shift around beneath us
      # unexpectedly.
      NIXPKGS_REV: "XXX" # Set this in a derived environment.

    steps:
      - run:
          # Get NIX_PATH set for the rest of the job so that the revision of
          # nixpkgs we selected will be used everywhere Nix pulls in software.
          # There is no way to set an environment variable containing the
          # value of another environment variable on CircleCI except to use
          # the `BASE_ENV` feature as we do here.
          name: "Setup NIX_PATH Environment Variable"
          command: |
            echo "export NIX_PATH=nixpkgs=https://github.com/NixOS/nixpkgs/archive/$NIXPKGS_REV.tar.gz" >> $BASH_ENV

      # Get *our* source code.
      - "checkout"
      - run:
          # And the rest of it.
          name: "Finish checking out source"
          command: |
            git submodule init
            git submodule update

      - "run":
          # CircleCI won't let us interpolate NIXPKGS_REV into a cache key.
          # Only CircleCI's own environment variables or variables set via the
          # web interface in a "context" can be interpolated into cache keys.
          # However, we can interpolate the checksum of a file...  Since we
          # don't care about the exact revision, we just care that a new
          # revision gives us a new string, we can write the revision to a
          # file and then put the checksum of that file into the cache key.
          # This way, we don't have to maintain the nixpkgs revision in two
          # places and risk having them desynchronize.
          name: "Prepare For Cache Key"
          command: |
            echo "${NIXPKGS_REV}" > nixpkgs.rev

      - restore_cache:
          # Get all of Nix's state relating to the particular revision of
          # nixpkgs we're using.  It will always be the same.  CircleCI
          # artifacts and nixpkgs store objects are probably mostly hosted in
          # the same place (S3) so there's not a lot of difference for
          # anything that's pre-built.  For anything we end up building
          # ourselves, though, this saves us all of the build time (less the
          # download time).
          #
          # Read about caching dependencies: https://circleci.com/docs/2.0/caching/
          name: "Restore Nix Store Paths"
          keys:
            # Construct cache keys that allow sharing as long as nixpkgs
            # revision is unchanged.
            #
            # If nixpkgs changes then potentially a lot of cached packages for
            # the base system will be invalidated so we may as well drop them
            # and make a new cache with the new packages.
            - nix-store-v1-{{ checksum "nixpkgs.rev" }}
            - nix-store-v1-

      - save_cache:
          name: "Cache Nix Store Paths"
          key: nix-store-v1-{{ checksum "nixpkgs.rev" }}
          paths:
            - "/nix"

      - run:
          name: "Build and Test"
          command: |
            ./ci-tools/run-tests.sh

  tests-2105:
    <<: *TESTS
    environment:
      NIXPKGS_REV: "21.05"

  tests-2111:
    <<: *TESTS
    environment:
      NIXPKGS_REV: "21.11"

workflows:
  version: 2
  all-tests:
    jobs:
      - "tests-2105"
      - "tests-2111"
      - "package-manylinux":
          name: "package-manylinux-2014_x86_64"
          executor: "manylinux-2014-x86_64"
          # The image this executor uses comes with no ssh client.  CircleCI
          # rewrites our git configuration to fetch sources over ssh.  Then it
          # fails if we don't have any ssh client.
          pre-command: "yum install -y openssh-clients"
          python: "/opt/python/cp37-cp37m/bin/python"
      - "package-manylinux":
          name: "package-manylinux_2_24-x86_64"
          executor: "manylinux_2_24-x86_64"
          # Similar to the manylinux-2014_x86_64 case.
          pre-command: "apt-get update -y && apt-get install -y openssh-client"
          python: "/opt/python/cp37-cp37m/bin/python"
      - "package-manylinux":
          name: "package-manylinux_x_y-aarch64"
          executor: "manylinux_x_y-aarch64"
          # The image this executor uses has an ssh client but is missing the
          # patchelf tool required by auditwheel.
          pre-command: |
            sudo apt-get update
            sudo apt-get install patchelf
          python: "python3"

      - "package-macos":
          matrix:
            parameters:
              # https://circleci.com/docs/2.0/testing-ios/#supported-xcode-versions
              xcode-version:
                # Latest macOS 10.14.x
                - "11.1.0"
                # Latest macOS 10.15.x
                - "12.4.0"
                # Latest macOS 11.x
                - "13.2.1"
          filters:
            # CircleCI does not run workflows for tags unless you explicitly
            # specify tag filters. Additionally, if a job requires any other
            # jobs (directly or indirectly), you must specify tag filters for
            # those jobs.
            # https://circleci.com/docs/2.0/configuration-reference/?section=configuration#tags
            branches:
              # Keep running on all branches
              only: "/.*/"
            tags:
              # Run on all release tags too
              only: "/v.*/"
