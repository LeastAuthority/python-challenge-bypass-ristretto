version: 2.1

commands:
  build-wheel:
    parameters:
      python:
        description: "The path to the Python executable to use"
        type: "string"

    description: "Build a Python wheel"
    steps:
      - "checkout"
      - run:
          # And the rest of it.
          name: "Finish checking out source"
          command: |
            git submodule init
            git submodule update
            git fetch --tags

      - run:
          name: "Install Rust Build Toolchain"
          command: |
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > /tmp/rustup-init
            sh /tmp/rustup-init -y --default-toolchain stable
            echo '. "$HOME"/.cargo/env' >> $BASH_ENV

      - run:
          name: "Get Python Build/Package Dependencies"
          command: |
            # Make sure we have a pip that's aware of Python version constraints
            << parameters.python >> -m pip install --upgrade pip
            # Pre-install these two setup_depends using pip so we don't have
            # to rely on whatever resolution logic setuptools would apply.
            << parameters.python >> -m pip install --upgrade milksnake setuptools_scm
            # And get these so we can build and then upload a wheel
            << parameters.python >> -m pip install wheel twine

      - run:
          name: "Build Wheel"
          command: |
            << parameters.python >> setup.py bdist_wheel

      - run:
          name: "Upload Wheel"
          command: |
            if [[ "$CIRCLE_TAG" == v* ]]; then
              # We're building a release tag so we should probably really
              # release it!
              repo="pypi"
            else
              # We're building anything else.  Exercise as much of the release
              # code as possible - but send it to the "test" package index,
              # not the "real" one.
              repo="testpypi"
              TWINE_PASSWORD="$TWINE_TESTPYPI_PASSWORD"
            fi
            << parameters.python >> -m twine upload --repository $repo dist/*

jobs:
  package-manylinux:
    parameters:
      python:
        description: "The path to the Python executable to use"
        type: "string"

      image:
        description: "The Docker image to use"
        type: "string"

    environment:
      # PyPI authentication configuration for twine so we can upload packages.
      # TWINE_PASSWORD is set in the CircleCI private configuration section.
      # In the CircleCI web app:
      #
      #    Project Settings ->
      #    Environment Variables ->
      #    Add Environment Variable ->
      #    Name: TWINE_PASSWORD
      #    Value: <a token issued by PyPI>
      #
      # The PyPI token is issued in the PyPI web app:
      #
      #    Manage ->
      #    Settings ->
      #    Create a token for ... ->
      #    Permissions: Upload
      #    Scope: Project: python-challenge-bypass-ristretto
      TWINE_USERNAME: "__token__"

    docker:
      - image: "<< parameters.image >>"

    steps:
      # The build needs SSH to update the submodule.
      - run:
          name: "Install SSH Client"
          command: |
            yum install -y openssh-clients

      - "build-wheel"

  package-macos:
    environment:
      # See package-manylinux2014_x86_64
      TWINE_USERNAME: "__token__"

    parameters:
      xcode-version:
        type: "string"

    macos:
      xcode: "<< parameters.xcode-version >>"

    steps:
      - "build-wheel"

  tests-template: &TESTS
    docker:
      # Run in a highly Nix-capable environment.
      - image: "nixorg/nix:circleci"

    environment:
      # Specify a revision of NixOS/nixpkgs to run against.  This essentially
      # pins the majority of the software involved in the build.  This
      # revision is selected arbitrarily.  It's somewhat current as of the
      # time of this comment.  We can bump it to a newer version when that
      # makes sense.  Meanwhile, the platform won't shift around beneath us
      # unexpectedly.
      NIXPKGS_REV: "XXX" # Set this in a derived environment.

    steps:
      - run:
          # Get NIX_PATH set for the rest of the job so that the revision of
          # nixpkgs we selected will be used everywhere Nix pulls in software.
          # There is no way to set an environment variable containing the
          # value of another environment variable on CircleCI except to use
          # the `BASE_ENV` feature as we do here.
          name: "Setup NIX_PATH Environment Variable"
          command: |
            echo "export NIX_PATH=nixpkgs=https://github.com/NixOS/nixpkgs/archive/$NIXPKGS_REV.tar.gz" >> $BASH_ENV

      # Get *our* source code.
      - "checkout"
      - run:
          # And the rest of it.
          name: "Finish checking out source"
          command: |
            git submodule init
            git submodule update

      - "run":
          # CircleCI won't let us interpolate NIXPKGS_REV into a cache key.
          # Only CircleCI's own environment variables or variables set via the
          # web interface in a "context" can be interpolated into cache keys.
          # However, we can interpolate the checksum of a file...  Since we
          # don't care about the exact revision, we just care that a new
          # revision gives us a new string, we can write the revision to a
          # file and then put the checksum of that file into the cache key.
          # This way, we don't have to maintain the nixpkgs revision in two
          # places and risk having them desynchronize.
          name: "Prepare For Cache Key"
          command: |
            echo "${NIXPKGS_REV}" > nixpkgs.rev

      - restore_cache:
          # Get all of Nix's state relating to the particular revision of
          # nixpkgs we're using.  It will always be the same.  CircleCI
          # artifacts and nixpkgs store objects are probably mostly hosted in
          # the same place (S3) so there's not a lot of difference for
          # anything that's pre-built.  For anything we end up building
          # ourselves, though, this saves us all of the build time (less the
          # download time).
          #
          # Read about caching dependencies: https://circleci.com/docs/2.0/caching/
          name: "Restore Nix Store Paths"
          keys:
            # Construct cache keys that allow sharing as long as nixpkgs
            # revision is unchanged.
            #
            # If nixpkgs changes then potentially a lot of cached packages for
            # the base system will be invalidated so we may as well drop them
            # and make a new cache with the new packages.
            - nix-store-v1-{{ checksum "nixpkgs.rev" }}
            - nix-store-v1-

      - save_cache:
          name: "Cache Nix Store Paths"
          key: nix-store-v1-{{ checksum "nixpkgs.rev" }}
          paths:
            - "/nix"

      - run:
          name: "Build and Test"
          command: |
            ./ci-tools/run-tests.sh

  tests-2105:
    <<: *TESTS
    environment:
      NIXPKGS_REV: "21.05"

  tests-2111:
    <<: *TESTS
    environment:
      NIXPKGS_REV: "21.11"

workflows:
  version: 2
  all-tests:
    jobs:
      - "tests-2105"
      - "tests-2111"
      - "package-manylinux":
          matrix:
            parameters:
              image: "quay.io/pypa/manylinux2014_x86_64"
              python: "/opt/python/cp37-cp37m/bin/python"

      - "package-macos":
          matrix:
            parameters:
              # https://circleci.com/docs/2.0/testing-ios/#supported-xcode-versions
              xcode-version:
                # Latest macOS 10.x
                - "12.4.0"
                # Latest macOS 11.x
                - "13.2.1"
          filters:
            # CircleCI does not run workflows for tags unless you explicitly
            # specify tag filters. Additionally, if a job requires any other
            # jobs (directly or indirectly), you must specify tag filters for
            # those jobs.
            # https://circleci.com/docs/2.0/configuration-reference/?section=configuration#tags
            branches:
              # Keep running on all branches
              only: "/.*/"
            tags:
              # Run on all release tags too
              only: "/v.*/"
